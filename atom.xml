<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Larry&#39;s Workspace</title>
  
  <subtitle>Welcome</subtitle>
  <link href="https://larrylai1993.github.io/atom.xml" rel="self"/>
  
  <link href="https://larrylai1993.github.io/"/>
  <updated>2026-01-28T16:21:55.094Z</updated>
  <id>https://larrylai1993.github.io/</id>
  
  <author>
    <name>Larry Lai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>人月神話（三）：為什麼軟體開發不能講民主？</title>
    <link href="https://larrylai1993.github.io/2026/01/29/mythical-man-month-ch4/"/>
    <id>https://larrylai1993.github.io/2026/01/29/mythical-man-month-ch4/</id>
    <published>2026-01-29T06:00:00.000Z</published>
    <updated>2026-01-28T16:21:55.094Z</updated>
    
    <content type="html"><![CDATA[<p>這篇〈貴族專制、民主政治與系統設計〉標題看起來很硬，充滿了 70 年代的古早味，但它其實探討了軟體開發中一個非常核心、甚至有點政治不正確的觀點：「民主」在設計系統時是行不通的。</p><p>這一章的核心邏輯，其實用現代開發的角度來看意外地精準。</p><h2 id="核心重點"><a href="#核心重點" class="headerlink" title="核心重點"></a>核心重點</h2><p>這是整本書最重要的概念之一。作者認為一個系統如果要好用，必須像是「由同一個人設計出來的」。</p><p>試想一下，如果十個工程師每個人都把自己覺得很酷的功能加進去，這個軟體最後就會變成一個四不像的縫合怪。使用者會覺得很混亂，因為 A 功能的操作邏輯和 B 功能完全不同。</p><p>所以作者主張：與其要一個擁有大量好點子但混亂的系統，不如要一個設計統一但功能普通的系統。</p><h2 id="貴族專制與慣老闆？"><a href="#貴族專制與慣老闆？" class="headerlink" title="貴族專制與慣老闆？"></a>貴族專制與慣老闆？</h2><p>如核心重點所陳述，作者提出了一個很極端的解法：設計權必須掌握在極少數人手裡，也就是所謂的貴族專制。</p><p>這會引發一個很大的矛盾：</p><p><strong>貴族（架構師）</strong>： 負責決定系統長什麼樣子、做什麼事。</p><p><strong>平民（實作者）</strong>： 只能決定怎麼做出來，不能決定要做什麼。</p><p>這聽起來超像慣老闆在壓榨員工對吧？讀者讀到這裡通常會很不爽，覺得自己變成了寫 Code 的機器，沒有創意空間。所以作者花了很多篇幅在解釋為什麼這不是壞事。</p><h2 id="現代觀點解讀"><a href="#現代觀點解讀" class="headerlink" title="現代觀點解讀"></a>現代觀點解讀</h2><p>這一章提到的角色與衝突，完全可以對應到現代軟體開發的常見職位。</p><p>作者所謂的架構師，其實就是現在負責寫 PRD 和定義 API 介面的 PM 或技術主管。他的工作是對使用者負責，告訴工程師使用者看到的是什麼。產品的規格不能讓工程師一人一句投票決定，必須由少數人拍板定案，產品才會有靈魂。</p><p>而實作者就是軟體工程師。我們的工作是對機器負責，想辦法把規格用最高效、最穩定的程式碼寫出來。</p><h2 id="為什麼「專制」對工程師反而是好事？"><a href="#為什麼「專制」對工程師反而是好事？" class="headerlink" title="為什麼「專制」對工程師反而是好事？"></a>為什麼「專制」對工程師反而是好事？</h2><p>這章最難懂也最精彩的地方，在於安撫工程師的論點。</p><p>首先，「怎麼做」其實比「做什麼」更難。架構師雖然決定了要蓋一座橋，但工程師要決定怎麼在不倒塌的情況下把橋蓋起來。技術實作本身的創意空間是非常巨大的，不需要去搶設計產品的創意。</p><p>其次，規格定死了，反而比較好做事。</p><p>如果你是工程師，應該遇過需求一直變的狀況。作者認為，架構師把規格定得越死，工程師反而越自由。因為你可以專心鑽研技術，不用擔心明天 PM 又改需求。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這章其實是在講分工的哲學。</p><p>軟體設計拒絕民主，為了讓軟體好用，產品規格必須由極少數人獨裁決定，才能保證風格統一。但工程師的創意應該發揮在「如何優雅地實現功能」，而不是去改動產品設計。</p><p>簡單來說：PM 把需求講清楚，不要讓工程師猜；工程師把 Code 寫漂亮，不要去亂改需求。這才是效率最高的開發模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這篇〈貴族專制、民主政治與系統設計〉標題看起來很硬，充滿了 70 年代的古早味，但它其實探討了軟體開發中一個非常核心、甚至有點政治不正確的觀點：「民主」在設計系統時是行不通的。&lt;/p&gt;
&lt;p&gt;這一章的核心邏輯，其實用現代開發的角度來看意外地精準。&lt;/p&gt;
&lt;h2 id=&quot;核</summary>
      
    
    
    
    <category term="加減讀點書系列" scheme="https://larrylai1993.github.io/categories/%E5%8A%A0%E6%B8%9B%E8%AE%80%E9%BB%9E%E6%9B%B8%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="人月神話" scheme="https://larrylai1993.github.io/tags/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%A9%B1/"/>
    
    <category term="讀書心得" scheme="https://larrylai1993.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>人月神話（三）：最佳分工的優秀外科手術隊伍</title>
    <link href="https://larrylai1993.github.io/2026/01/26/mythical-man-month-ch3/"/>
    <id>https://larrylai1993.github.io/2026/01/26/mythical-man-month-ch3/</id>
    <published>2026-01-26T04:30:00.000Z</published>
    <updated>2026-01-26T04:43:08.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一章聊到「人手越多，溝通成本越高，進度反而越慢」這個殘酷的事實。</p><p>既然如此，如果一個專案真的複雜到需要很多人怎麼辦？總不能因為怕溝通成本就永遠只讓一個人寫吧？</p><p>針對這個問題，作者提出了一個解決方案：<strong>菁英制（外科手術隊伍）</strong>。</p><p>這章的核心觀點相當直接且暴力：「<strong>與其讓 10 個普通工程師大家一起寫程式（民主制），不如讓 1 個超級工程師負責寫核心程式，其他 9 個人全部圍繞著他打雜（菁英制）。</strong>」</p><h2 id="為什麼叫「外科手術隊伍」？"><a href="#為什麼叫「外科手術隊伍」？" class="headerlink" title="為什麼叫「外科手術隊伍」？"></a>為什麼叫「外科手術隊伍」？</h2><p>作者在書中用 <strong>開刀房</strong> 來比喻最優的分工狀況：</p><p>在開刀房裡，雖然有很多人（麻醉師、護理師、助手），但<strong>真正動刀的只有一個人</strong>（主刀醫師）。</p><p>如果大家都搶著動刀，手術絕對會亂套。</p><p>其他人的存在，是為了讓主刀醫師能<strong>心無旁騖地開刀</strong>，不用去管擦汗、遞剪刀、確認病人血壓這些瑣事。而在軟體開發中，這些「瑣事」可能就是寫文件、測 Bug、維護工具、或是處理行政流程。</p><h2 id="組織分工示意圖"><a href="#組織分工示意圖" class="headerlink" title="組織分工示意圖"></a>組織分工示意圖</h2><p>我們可以把這個概念畫成一張圖，中間的核心就是那位「外科醫生」：</p><pre class="mermaid">graph TD    Surgeon["<b>外科醫生 (The Surgeon)</b><br>核心架構師 / Tech Lead"]    Copilot["<b>副手 (The Copilot)</b><br>資深工程師 / Code Reviewer"]    Admin["<b>管理員 (The Administrator)</b><br>專案經理 (PM)"]    Editor["<b>編輯 (The Editor)</b><br>技術文件撰寫"]    Clerk["<b>碼農 (The Program Clerk)</b><br>Git / 版本控制"]    Toolsmith["<b>工具維護人 (The Toolsmith)</b><br>DevOps / 平台工程師"]    Tester["<b>測試人員 (The Tester)</b><br>QA / 測試工程師"]    Surgeon --> Copilot    Surgeon --> Admin    subgraph Technical ["技術支援 (Technical Support)"]        Copilot --> Toolsmith        Copilot --> Tester    end    subgraph Administrative ["行政支援 (Admin Support)"]        Admin --> Editor        Admin --> Clerk    end</pre><h2 id="那些讓你看不懂的角色對照表"><a href="#那些讓你看不懂的角色對照表" class="headerlink" title="那些讓你看不懂的角色對照表"></a>那些讓你看不懂的角色對照表</h2><p>書中洋洋灑灑寫了一堆分工解釋得很複雜，但根據上面我整理的圖，搭配下面職位解釋，應該就相當清楚了。</p><table><thead><tr><th align="left">角色 (Role)</th><th align="left">現代對應 (Modern Equivalent)</th><th align="left">職責說明 (Responsibilities)</th></tr></thead><tbody><tr><td align="left"><strong>外科醫生 (The Surgeon)</strong></td><td align="left"><strong>核心架構師 &#x2F; Tech Lead</strong></td><td align="left">他是老大，負責寫<strong>最核心的程式碼</strong>，並做所有技術決定。<br>強調：<strong>整個系統的概念必須來自「一個人的腦袋」，才能保持一致性（Conceptual Integrity）。</strong></td></tr><tr><td align="left"><strong>副手 (The Copilot)</strong></td><td align="left"><strong>資深工程師 &#x2F; Code Reviewer</strong></td><td align="left">他是外科醫生的備份，能理解所有程式碼，也能隨時接手，但他是來「輔佐」而非「競爭」的。他主要負責思考、討論、以及分擔程式碼撰寫，但他寫的碼最終還是要經過外科醫生的認可。</td></tr><tr><td align="left"><strong>管理員 (The Administrator)</strong></td><td align="left"><strong>專案經理 (PM)</strong></td><td align="left">負責處理錢、人事、排程，讓外科醫生不用分心去管行政雜務。</td></tr><tr><td align="left"><strong>編輯 (The Editor) &amp; 秘書</strong></td><td align="left"><strong>技術文件撰寫 &#x2F; 文書處理</strong></td><td align="left">負責把外科醫生的草稿變成正式文件。現在很多時候這也是工程師自己兼著做，或者有專門的 Technical Writer。</td></tr><tr><td align="left"><strong>碼農 (The Program Clerk)</strong></td><td align="left"><strong>Git &#x2F; 版本控制系統</strong></td><td align="left">這個角色在現代看來最過時。在 70 年代，程式碼是寫在紙上或打孔卡上的，需要專人管理實體的檔案櫃。現在這個工作已經被 GitHub &#x2F; GitLab 取代了。</td></tr><tr><td align="left"><strong>工具維護人 (The Toolsmith)</strong></td><td align="left"><strong>DevOps &#x2F; 平台工程師</strong></td><td align="left">負責維護編譯器、測試環境，確保外科醫生的電腦和工具隨時順手好用。</td></tr><tr><td align="left"><strong>測試人員 (The Tester)</strong></td><td align="left"><strong>QA &#x2F; 測試工程師</strong></td><td align="left">專門設計測試案例來找外科醫生的麻煩（Bug）。</td></tr></tbody></table><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這章看起來很亂，列了一堆職位，其實只講了一件事：</p><p><strong>為了保證軟體設計的「概念完整性」（Conceptual Integrity）：團隊應該是「一主多從」的結構，而不是「人人平等」的結構。</strong></p><p>就像 Apple 的產品之所以風格統一，是因為背後有強大的意志（Jobs&#x2F;Ive）在主導。如果軟體設計變成民主投票，每個人都把自己的想法加進去，最後做出來的一定是四不像。</p><p><del>就跟人一樣，只想討好所有人最後可是大家都討厭你的</del></p><p>由一個最強的人負責思考和設計，其他人則是作為他的擴充套件，幫他把生產力放大，而不是每個人都跳進去亂改核心設計，或者嘗試在自己非專業的地方發表毫無意義的想法。</p><p>這聽起來很菁英主義？沒錯，就是菁英主義。可能有些人會因此感到不舒服，有想法無法說出口。但抱歉了，因為<strong>概念完整性是系統設計中最重要的考量</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一章聊到「人手越多，溝通成本越高，進度反而越慢」這個殘酷的事實。&lt;/p&gt;
&lt;p&gt;既然如此，如果一個專案真的複雜到需要很多人怎麼辦？總不能因</summary>
      
    
    
    
    <category term="加減讀點書系列" scheme="https://larrylai1993.github.io/categories/%E5%8A%A0%E6%B8%9B%E8%AE%80%E9%BB%9E%E6%9B%B8%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="人月神話" scheme="https://larrylai1993.github.io/tags/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%A9%B1/"/>
    
    <category term="讀書心得" scheme="https://larrylai1993.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>電影觀後心得：1988 上映的《飛進未來》</title>
    <link href="https://larrylai1993.github.io/2026/01/25/movie-big-review/"/>
    <id>https://larrylai1993.github.io/2026/01/25/movie-big-review/</id>
    <published>2026-01-24T17:06:00.000Z</published>
    <updated>2026-01-24T18:34:59.060Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 Netflix 看到《飛進未來》這部片，乍看男主角有點眼熟，原來就是湯姆漢克啊……總之一開始其實是衝著我認識這男主角的關係，才按進了這部 1988 年的老片。</p><p>一開始這歸類在喜劇我是有點莫名，直到看到 Susan 被 Josh 拉上彈簧床的那瞬間，我才明白被歸類在喜劇的原因 LOL</p><p>不過這部片算是超乎預期的好看，尤其像我這種已經在職場打滾過一陣子，已經被磨平稜角這種人。後座力感覺又更強了一些。</p><h2 id="許願機與一夜長大"><a href="#許願機與一夜長大" class="headerlink" title="許願機與一夜長大"></a>許願機與一夜長大</h2><p>這部劇情就是我們熟知的因緣際會變成大人了，這部的主角叫做 Josh，他在某個遊樂場對著一台許願機許願讓自己變成大人。隔天醒來，他真的變成了 30 歲。但，他只是肉體被拉長了，靈魂還是那個單純的 13 歲男孩。</p><p>於是呢……他就和他的好朋友跑去紐約想要找到許願機，再次許願然後變回小孩。</p><p>那個晚上他住在紐約聽到此起彼落的爭吵聲、眾多不懷好意的眼光、還有突然在街頭想起的槍響。他嚇得把門鎖好，扣上鎖鏈，然後把耳朵遮了起來。</p><p>這段對我來說就像是剛出社會被受洗禮的時候一樣，不管是到了新城市、新環境，我都會有那種想把自己鎖進房間藏起來的時刻。</p><p>但其實 Josh 過陣子就習慣了，他甚至還能聽著槍聲吃他的 Oreo、看著電視，絲毫不受影響。就和你我一樣出社會久了其實對那些職場上的紛爭或什麼的都很習慣。</p><h2 id="玩具公司的-Susan-老闆"><a href="#玩具公司的-Susan-老闆" class="headerlink" title="玩具公司的 Susan &amp; 老闆"></a>玩具公司的 Susan &amp; 老闆</h2><p>Susan 其實不壞，她只是太習慣這個社會的遊戲規則。她知道怎麼展現優勢、怎麼利用手段在公司往上爬。對她來說，這就是「大人」該有的樣子：精明、世故、隨時處於備戰狀態。</p><p>直到那天她遇到了 Josh。</p><p>當她被拉上去跳著彈簧床的那一刻，防護罩破了。她笑得跟孩子一樣，那一刻她才發現自己內心深處還藏著一個 13 歲的小女孩。這也讓我想到那場經典的鋼琴戲，那個整天只想著營收數據的老闆，在跟 Josh 一起跳著地板鋼琴時，眼神裡那個單純熱愛玩具的靈魂也被喚醒了。</p><p>我們大部分的人心裡其實都住著那個孩子，只是出社會久了，我們學會了穿上盔甲、忘了初心，甚至忘了自己原本的模樣。</p><p>正是因為 Susan 被喚醒了這份純真，她才開始意識到身邊那些所謂的「菁英男友」有多麽乏味，也為接下來那句讓我起雞皮疙瘩的台詞埋下了伏筆。</p><h2 id="Josh-是個成熟的大人"><a href="#Josh-是個成熟的大人" class="headerlink" title="Josh 是個成熟的大人"></a>Josh 是個成熟的大人</h2><p>整部片最讓我起雞皮疙瘩的，其實是一句看似普通的台詞。Susan 跟很愛嫉妒的男友要分手的時候，她男友講了些不好聽的話，Susan 只有冷冷的回：「Josh 是個成熟的大人」。</p><p>這段真的非常有趣，畢竟你知我知獨眼龍也知，導演跟我們這群觀眾都知道：Josh 根本不是什麼成熟的大人，他就是個小孩。但為什麼在職場打滾多年的蘇珊會產生這種誤解？</p><p>因為 Susan 身旁的那些「真大人」都太讓人疲憊了，就像 Susan 在派對上已經對那些話題感到厭倦一樣。</p><p>我們所謂的「成熟」，往往意味著不理會流言蜚語、有話直說，但其實很多成熟的特質，都應對著小孩原有的純粹。</p><p>總之 Susan 誤把 Josh 的「純真」讀解成了「世故後的從容」。</p><p>當大家在會議室裡對著那個無聊變形機器人虛與委蛇的時候，只有 Josh 敢說：「我不懂，這個哪裡好玩？它變成了蟲，然後呢？」</p><p><del>你看，這什麼 78 人</del></p><p>原來在充滿算計的大人世界裡，「不玩心理戰」竟然變成了一種稀有的成熟特質、一針見血變成了專業及勇敢的特徵，假裝同意變成了出社會的必修。Josh 的「成熟」，來自於他根本不懂那些複雜的遊戲規則。他想玩跳跳床就玩、想吃玉米筍就專心吃、喜歡妳就直視妳的眼睛聽妳說話。</p><p><del>我們這些自以為成熟的大人，到底是在哪個環節壞掉的啊？</del></p><p>湯姆漢克這部片演得真的好，他不是在演一個「傻瓜」，而是在演一個「努力想適應大人世界的聰明小孩」。他眼裡的慌張跟好奇是乾淨的，這也是為什麼蘇珊會愛上他的原因。</p><h2 id="成長的代價"><a href="#成長的代價" class="headerlink" title="成長的代價"></a>成長的代價</h2><p>電影的後半段，Josh 雖然有了錢、有了超大的公寓、有了愛情，但他被死黨點了一下才發現自己正在遺失某些東西（其實就是從電影中段他穿起西裝開始）。</p><p>於是他開始想念家，想念那個還可以跟死黨無憂無慮打電動的日子。</p><p>最後的分離之所以感人，是因為這段愛情註定無解。Susan 愛上的，是那個「住在大人身體裡的小孩靈魂」。一旦魔法解除，Josh 變回 13 歲，Susan 愛的那個人也就消失了。</p><p>然而這也是我很愛 Susan 的原因，她就如 Josh 說的那樣，是他這輩子遇過最好的人。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>長大這件事最殘忍的，不是變老，也不是責任變重。</p><p>而是我們忘記了怎麼單純地因為一個玩具而大笑。</p><p>也許真正的成熟，不是學會變得複雜，而是像 Josh 一樣，即便在這個不得不複雜的世界裡，還能試著保有那顆誠實面對自己的心。</p><p>這是一部給大人看的童話，提醒我們：別為了扮演一個大人，而殺死了心裡那個 13 歲的孩子。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在 Netflix 看到《飛進未來》這部片，乍看男主角有點眼熟，原來就是湯姆漢克啊……總之一開始其實是衝著我認識這男主角的關係，才按進了這部 1988 年的老片。&lt;/p&gt;
&lt;p&gt;一開始這歸類在喜劇我是有點莫名，直到看到 Susan 被 Josh 拉上彈簧床的那瞬間，我才</summary>
      
    
    
    
    <category term="有感而發" scheme="https://larrylai1993.github.io/categories/%E6%9C%89%E6%84%9F%E8%80%8C%E7%99%BC/"/>
    
    
    <category term="電影" scheme="https://larrylai1993.github.io/tags/%E9%9B%BB%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>人月神話（二）：人月就是個謊言</title>
    <link href="https://larrylai1993.github.io/2026/01/23/mythical-man-month-ch2/"/>
    <id>https://larrylai1993.github.io/2026/01/23/mythical-man-month-ch2/</id>
    <published>2026-01-23T08:20:00.000Z</published>
    <updated>2026-01-23T09:00:35.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這篇作者直接開門見山說：<strong>缺乏合理的時間進度，是造成專案延遲最主要的原因，比其他所有因素加起來的影響還大。</strong></p><p>但這問題會一直發生吧？專案估算過度樂觀時常不是真正的樂觀，而是因為中途發現需求與原先預估的有差異。就有點像是大家以為原先的道路是正確的，但走了一段才發現是死路，這時候只能回頭重走，但回頭重走的時間成本往往會被忽略。</p><p>應該說怎麼可能會預估得到會走錯路？</p><p>針對這個問題，作者點出了一個關鍵心態，正是這個心態讓我們容易忽略掉那些潛在的錯路。</p><h2 id="工程師的通病：過度樂觀"><a href="#工程師的通病：過度樂觀" class="headerlink" title="工程師的通病：過度樂觀"></a>工程師的通病：過度樂觀</h2><p>作者很直白的說：<strong>所有的程式設計師都是樂觀主義者</strong>。</p><p>我們總相信這次一定會順利、我剛剛修完最後一個 Bug 了、應該差不多了、可以上線了之類的鬼話。</p><p><del>就像人生十大錯覺一樣</del></p><p>結果呢？Bug 總是會用各種你想像不到的方式再冒出來。或者這個流程一定沒問題，結果使用者一看發現不太對勁。</p><p>這種樂觀，來自於我們工作的介質太容易駕馭了。寫程式不像蓋房子要搬木頭、不像雕刻要跟石頭對抗。我們只需要鍵盤和螢幕，想法就能直接變成程式碼。這種純思考的創作方式，讓我們以為一切都在掌控之中。</p><p>但問題在於：<strong>我們的思考本身是有缺陷的</strong>。所以 Bug 永遠會存在，而我們的樂觀，往往只是錯覺。</p><p><del>難怪我永遠都會把 ticket 的點數少估</del></p><h2 id="人月：一個危險的神話"><a href="#人月：一個危險的神話" class="headerlink" title="人月：一個危險的神話"></a>人月：一個危險的神話</h2><p>這章最核心的概念就是：<strong>人月（Man-Month）是一個危險且具有欺騙性的單位</strong>。</p><p>它暗示著人力和時間可以互換——需要 12 人月的工作，可以讓 3 個人做 4 個月，也可以讓 12 個人做 1 個月。</p><p><strong>會相信這種道理代表你也相信 10 個孕婦一個月就能生一個小孩ＸＤ</strong></p><p>作者提了幾種情況：</p><ol><li><strong>完全可分割的任務</strong>：像收割麥子，加人確實能縮短時間。</li><li><strong>無法分割的任務</strong>：<strong>無論多少個媽媽，懷孕都需要十個月</strong>。很多軟體開發的流程，特別是測試和除錯，就是這種性質。</li><li><strong>需要溝通的可分割任務</strong>：這是最常見的情況。加人確實能分擔工作，但溝通成本會隨之增加。人越多，溝通成本越高，效益會打折扣。</li><li><strong>關係錯綜複雜的任務</strong>：溝通成本可能會完全抵消分工帶來的好處，甚至讓情況變得更糟。</li></ol><blockquote><p>如果每個人都要跟其他所有人溝通，工作量會按照 <strong>n(n-1)&#x2F;2</strong> 遞增。</p></blockquote><p>三個人的溝通量是兩個人的三倍，四個人是六倍。這還沒算上開會，沒有算上那個人可能是個溝通能力極低的人。</p><h2 id="系統測試：最容易被低估的環節"><a href="#系統測試：最容易被低估的環節" class="headerlink" title="系統測試：最容易被低估的環節"></a>系統測試：最容易被低估的環節</h2><p>作者提供了一個他的經驗法則：</p><ul><li><strong>1&#x2F;3</strong> 用於計畫</li><li><strong>1&#x2F;6</strong> 用於寫程式</li><li><strong>1&#x2F;4</strong> 用於元件測試與早期系統測試</li><li><strong>1&#x2F;4</strong> 用於系統測試</li></ul><p><strong>測試加起來佔了一半的時間</strong>，而寫 Code 只佔 1&#x2F;6。</p><p>現實中，大多數專案都低估了測試所需的時間。結果呢？延遲往往發生在專案的尾聲，這時候人力成本已經到頂、客戶已經在等、其他依賴你產品的商業活動也都卡住了。這種「末期爆炸」的代價，遠比預期延遲的成本高太多了。</p><h2 id="專案救火越救越大"><a href="#專案救火越救越大" class="headerlink" title="專案救火越救越大"></a>專案救火越救越大</h2><p>這章的結尾，作者丟出了那句著名的法則：</p><blockquote><p><strong>Adding manpower to a late software project makes it later.</strong><br><strong>向進度落後的專案增加人手，只會使進度更加落後。</strong></p></blockquote><p>這聽起來很反直覺，但原因其實很簡單：</p><ol><li><strong>新人需要培訓</strong>：這會消耗原有成員的時間。</li><li><strong>任務需要重新分配</strong>：已經完成的工作可能會被打亂。</li><li><strong>溝通成本增加</strong>：人越多，協調越複雜。</li><li><strong>系統測試需要延長</strong>：因為整體情況變得更複雜了。</li></ol><p>所以，當專案落後的時候，最糟糕的反應其實是加人。這就像用汽油滅火，只會讓火越燒越大。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這一章讀完，有種被醍醐灌頂的感覺。</p><p>我們常常在專案延遲的時候，第一個念頭就是「找更多人來幫忙」。但作者告訴我們，這通常只會讓事情更糟。<strong>真正該做的，是重新評估時程、縮減範圍、或是坦然接受延遲。</strong></p><p>人月，終究只是一個神話。我們不應該被這個看似合理的單位所欺騙。所以到底怎樣是好的估算？</p><p>在這章還沒有答案，就繼續看下去吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;這篇作者直接開門見山說：&lt;strong&gt;缺乏合理的時間進度，是造成專案延遲最主要的原因，比其他所有因素加起來的影響還大。&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="加減讀點書系列" scheme="https://larrylai1993.github.io/categories/%E5%8A%A0%E6%B8%9B%E8%AE%80%E9%BB%9E%E6%9B%B8%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="人月神話" scheme="https://larrylai1993.github.io/tags/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%A9%B1/"/>
    
    <category term="讀書心得" scheme="https://larrylai1993.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>人月神話（一）：我們都在焦油坑裡掙扎嗎？</title>
    <link href="https://larrylai1993.github.io/2026/01/23/mythical-man-month-ch1/"/>
    <id>https://larrylai1993.github.io/2026/01/23/mythical-man-month-ch1/</id>
    <published>2026-01-22T18:05:00.000Z</published>
    <updated>2026-01-23T02:39:04.564Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/../Images-Posts/mythical-man-month/effor-program-product-1.png"                      alt="Tar Pit"                ></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近翻 linkedin 剛好看到有人推薦這本書：<strong>《人月神話》（The Mythical Man-Month）</strong>。</p><p>問一問才發現原來這本書是號稱軟體工程界的聖經，所以想了想還是要撥點時間看吧？也許能給現在的自己有些什麼啟發。</p><p>那就開啟了不知道會不會寫完的這本書的讀書心得吧…</p><hr><p>第一章的標題：<strong>焦油坑（The Tar Pit）</strong>。</p><p>作者 Fred Brooks 引用了史前巨獸在焦油坑掙扎的場景：恐龍、猛獁象、劍齒虎，這些強大的生物在焦油中掙扎，越是猛烈，纏得越緊。最後，沒有誰能逃脫。</p><p>但我們是人，我們可能會享受這個掙扎的過程。因為快樂總是伴隨著苦痛，而煩惱即是菩提。我們總在焦油坑裡掙扎，但偶爾，我們也能爬上岸，享受一下陽光。</p><p>而這，就是開發的日常。</p><h2 id="什麼是「程式系統產品」？"><a href="#什麼是「程式系統產品」？" class="headerlink" title="什麼是「程式系統產品」？"></a>什麼是「程式系統產品」？</h2><p>這一章提到了一個很有趣的概念，也是我很喜歡的一張圖（Figure 1.1），解釋了為什麼我們寫一個能跑的「程式」（Program），跟做出一個能賣的「程式系統產品」（Programming Systems Product），所需的成本會有 <strong>9 倍</strong> 的差距。</p><ul><li><strong>Program</strong>：你自己寫爽的，能在你的機器上跑，能在你的腦袋裡運作。成本：1x。</li><li><strong>Programming Product（程式產品）</strong>：要通用化、要測試、要有文件。成本：3x。</li><li><strong>Programming System（程式系統）</strong>：要跟別的元件介接、要遵守介面規範、要整合測試。成本：3x。</li><li><strong>Programming Systems Product（程式系統產品）</strong>：<strong>也就是我們每天在做的事</strong>。既要通用化又要系統化。3x * 3x &#x3D; <strong>9x</strong>。</li></ul><p>很多時候老闆（或是我們自己）都會誤判，以為把一個 Prototype 變成產品很快。別傻了，那個 9 倍的坑就在那裡等著你。</p><h2 id="為什麼我們還在這裡？"><a href="#為什麼我們還在這裡？" class="headerlink" title="為什麼我們還在這裡？"></a>為什麼我們還在這裡？</h2><p>既然是焦油坑，那為什麼我們這群工程師還前仆後繼地跳進去？Brooks 列出了這個職業的 <strong>樂趣（Joys）</strong> 與 <strong>苦惱（Woes）</strong>。</p><h3 id="職業的樂趣"><a href="#職業的樂趣" class="headerlink" title="職業的樂趣"></a>職業的樂趣</h3><ol><li><strong>純粹的創造</strong>：就像上帝創造世界一樣，我們創造事物。</li><li><strong>對他人有用</strong>：做出來的東西是真的有人在用的。</li><li><strong>魔術般的魅力</strong>：看著一行行程式碼變成會動的畫面，那種成就感無可比擬。</li><li><strong>持續學習</strong>：這個領域永遠不會重複，永遠有新東西。（雖然有時候這也是一種這折磨…）</li><li><strong>易於駕馭的介質</strong>：我們的畫布是記憶體，我們的畫筆是鍵盤，我們可以憑空蓋出城堡，不需要磚瓦。</li></ol><h3 id="職業的苦惱"><a href="#職業的苦惱" class="headerlink" title="職業的苦惱"></a>職業的苦惱</h3><ol><li><strong>追求完美</strong>：電腦是無情的，少一個分號就是跑不動。我們必須強迫自己追求完美。</li><li><strong>依賴他人</strong>：你的程式跑不對，可能是 OS 的鍋，可能是 Library 的雷，甚至可能是同事的 API 文件沒寫好（或是根本沒寫）。</li><li><strong>枯燥的除錯</strong>：設計是有趣的，但抓 Bug 是線性的、甚至是指數級的痛苦。</li><li><strong>產品過時</strong>：當你終於把產品做出來，它可能已經過時了。</li></ol><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>雖然我們常抱怨 Requirements 一直改、在那邊解幾百年前的 Legacy Code、或是為了別人的 Bug 加班到半夜。但說實話，當我們看著系統成功上線，解決了用戶的問題，那種「<strong>我在焦油坑裡存活下來了</strong>」的快感，或許就是讓我們離不開這個行業的原因吧。</p><p>我們都是在焦油坑裡掙扎的巨獸，但偶爾，我們也能爬上岸，享受一下陽光。</p><p>這是我讀完第一章的小小心得，如果你也在焦油坑裡，別忘了，你並不孤單。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/../Images-Posts/mythi</summary>
      
    
    
    
    <category term="加減讀點書系列" scheme="https://larrylai1993.github.io/categories/%E5%8A%A0%E6%B8%9B%E8%AE%80%E9%BB%9E%E6%9B%B8%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="人月神話" scheme="https://larrylai1993.github.io/tags/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%A9%B1/"/>
    
    <category term="讀書心得" scheme="https://larrylai1993.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>你是真的可以解決問題的工程師，還是只想把卡關掉的 Mr. Meeseeks？</title>
    <link href="https://larrylai1993.github.io/2026/01/13/solve-problem-or-just-meeseeks/"/>
    <id>https://larrylai1993.github.io/2026/01/13/solve-problem-or-just-meeseeks/</id>
    <published>2026-01-13T15:31:15.000Z</published>
    <updated>2026-01-13T16:57:49.285Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/../Images-Posts/solve-problem-or-just-meeseeks/1-mrmeeseeks.jpg"                      alt="Rick and Morty"                ></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近接到一場小型的演講邀約，在著手整理十年職涯回顧時，腦中突然浮現《Rick and Morty》的某一集。那集的故事與角色設定，簡直是當代軟體開發職場的縮影。</p><p>在那集裡，只要按下按鈕，就能召喚出一種名為「Mr. Meeseeks」的藍色生物。他們存在的法則很簡單：<strong>解決單一任務，完成後立刻消失</strong>。</p><p>對他們而言，<strong>存在的每一秒都是痛苦，唯一的目標就是把事情做完然後 poof! 消失。</strong></p><p>有個橋段讓我最印象深刻，Jerry（主角的老爸，是一個超廢角色）想要精進高爾夫球技。Rick 召喚了 Meeseeks 來教他，但 Jerry <strong>拒絕改變</strong>，因為他不想調整錯誤的握桿姿勢，無法拋棄肌肉記憶，只想依賴別人幫他達成結果。可想而知沒有付出又怎麼會有收穫？</p><p>這兩個角色，正好映射出職場上兩種極端的工程師類型：</p><h2 id="第一種：The-Meeseeks-Type（敷衍的執行者）"><a href="#第一種：The-Meeseeks-Type（敷衍的執行者）" class="headerlink" title="第一種：The Meeseeks Type（敷衍的執行者）"></a>第一種：The Meeseeks Type（敷衍的執行者）</h2><p>這類人的眼裡沒有架構，沒有可維護性，他的眼裡，只有 Jira 上的那張卡。</p><p>對他來說，產品的生命週期、使用者體驗、業務是否會賣得好，都不是重點。他的目標從來不是解決長遠問題，而是讓這張卡從 To-Do 移動到 Done。</p><ul><li><strong>特徵：</strong> 極度的任務導向，缺乏面的思考，決策只看當下，不管以後。反正以後都離職了，誰管他</li><li><strong>工作模式：</strong> 為了趕上線，不惜破壞設計模式、疊床架屋，或是直接 hardcode。技術債繼續堆積對他來說無所謂，反正卡解掉就好。</li></ul><p>對 Meeseeks 型工程師而言，<strong>Working Software 只是手段，停止工作才是目的。</strong> 他們不想做額外優化，不想寫文件。這種交差了事的態度，往往是專案技術債的最大來源，也就是折磨你各位千百個夜晚、需要通靈才看得懂的那些破 Code。</p><h2 id="第二種：The-Jerry-Type（拒絕成長的依賴者）"><a href="#第二種：The-Jerry-Type（拒絕成長的依賴者）" class="headerlink" title="第二種：The Jerry Type（拒絕成長的依賴者）"></a>第二種：The Jerry Type（拒絕成長的依賴者）</h2><p>Jerry 講白了，就是團隊裡那個<strong>拒絕思考、拒絕改變</strong>的雷隊友。</p><p>如前所述，Jerry 想要進步，卻<strong>不願意調整姿勢</strong>。當 Meeseeks 給出專業建議時，Jerry 充耳不聞，甚至怪罪工具不好用。</p><p>閉上眼睛想一下，你身邊是否也有具備以下特徵的人？</p><ul><li><strong>拒絕深入問題：</strong> 遇到 Bug，第一反應不是看 Log、Google 或問 AI，而是直接開口問人，期望別人給出直接解答。</li><li><strong>Spoon-feeding（餵養心態）：</strong> 不願閱讀文件，不願理解系統邏輯，總是要人手把手教。永遠處於不求甚解的狀態，下次遇到同樣問題又要再來一次。</li><li><strong>抗拒成長：</strong> 當別人指出問題、或建議更好的架構時，他的反應往往是拒絕改變，可能會說反正現在能用就好。</li></ul><p>Jerry 型人格最大的問題在於<strong>怠惰</strong>。他不願付出相對應的勞動來換取成果，只希望成果從天上掉下來。</p><h2 id="拒絕成為這兩種人"><a href="#拒絕成為這兩種人" class="headerlink" title="拒絕成為這兩種人"></a>拒絕成為這兩種人</h2><p>在職場打滾久了，我們很容易因為疲憊而想當 Mr. Meeseeks，只想交差了事，趕快下班，拒絕當社畜；或是因為怠惰而變成 Jerry，不想動腦，只想依賴別人。</p><p>但撇開公司是否虧待你不談（說實話，如果真的虧待，你早該離開了），<strong>你的技術與態度，最終帶得走的都是你自己的資產。</strong></p><p>回歸正題，一個有價值的工程師<del>社畜</del>之所以有價值，關鍵在哪？</p><ol><li><strong>解決問題的層次：</strong> 我們關注的不只是卡的狀態，而是使用者的痛點是否真的被解決、做的東西有沒有符合產品方向。我們願意多花時間重構、多做檢查，因為我們對<strong>自己的產出品質</strong>負責。</li><li><strong>長遠的思考：</strong> 思考目前的實作有沒有擴充性？能不能順手把架構調整到位？而不只是為了交差了事。</li><li><strong>主動的姿態：</strong> 遇到問題先思考、先查證。願意學習新技術、接受 Code Review，而不是永遠指望別人來幫我們擦屁股。</li></ol><p>這十年來，我學到最重要的一課或許就是：<strong>別當那個只想「消失」的工具人，也別當那個拒絕改變的巨嬰。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/../Images-Posts/solve</summary>
      
    
    
    
    <category term="賴瑞碎碎念" scheme="https://larrylai1993.github.io/categories/%E8%B3%B4%E7%91%9E%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="心法" scheme="https://larrylai1993.github.io/tags/%E5%BF%83%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用 ActiveRecord 時遭遇 only_full_group_by 的錯誤</title>
    <link href="https://larrylai1993.github.io/2024/08/02/only-full-groupby-problem/"/>
    <id>https://larrylai1993.github.io/2024/08/02/only-full-groupby-problem/</id>
    <published>2024-08-02T10:00:40.000Z</published>
    <updated>2026-01-09T13:09:22.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySql 版本 5.7 以上都會自己預設開啟這個 <code>ONLY_FULL_GROUP_BY</code>。這個設定的目的主要是提高 SQL 查詢的準確性和一致性，避免導致一些人為疏失或其他預期外的錯誤發生。</p><p>舉例來說就是明明 SELECT 了全部的欄位，在做 GROUP BY 的時候卻只有部分欄位，其實是不符合 SQL 的標準。</p><h2 id="這個設定要防止什麼？"><a href="#這個設定要防止什麼？" class="headerlink" title="這個設定要防止什麼？"></a>這個設定要防止什麼？</h2><blockquote><p>防止非預期的結果</p></blockquote><p>假設我們有一個名為<code>employees</code>的表，資料如下：</p><table><thead><tr><th>id</th><th>name</th><th>department</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>Alice</td><td>Sales</td><td>50000</td></tr><tr><td>2</td><td>Bob</td><td>Sales</td><td>60000</td></tr><tr><td>3</td><td>Carol</td><td>HR</td><td>55000</td></tr><tr><td>4</td><td>David</td><td>HR</td><td>52000</td></tr></tbody></table><p>現在，考慮以下查詢：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, name, <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br></pre></td></tr></table></figure></div><p>在沒有 ONLY_FULL_GROUP_BY 模式的情況下，這個查詢可能會執行，但結果是不確定的。為什麼？</p><ol><li><code>department</code>列在 GROUP BY 子句中，所以沒問題。</li><li><code>AVG(salary)</code>是一個聚合函數，也沒問題。</li><li>但<code>name</code>列既不在 GROUP BY 子句中，也不是聚合函數的一部分。</li></ol><p>這時候問題來了</p><blockquote><p>如果你要取用<code>name</code>，那資料庫應該返回哪個<code>name</code>？</p></blockquote><p>啟用 ONLY_FULL_GROUP_BY 後，MySQL 會拒絕執行這個查詢，並給出一個錯誤，提示<code>name</code>列應該要麼包含在 GROUP BY 子句中，要麼使用聚合函數。</p><p>一個正確的查詢可能是：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, GROUP_CONCAT(name), <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br></pre></td></tr></table></figure></div><p>或者：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br></pre></td></tr></table></figure></div><p>這樣，查詢結果就是明確和可預測的，避免了可能的歧義和錯誤。</p><p>通過強制執行這種規則，ONLY_FULL_GROUP_BY 模式幫助開發者寫出更清晰、更可靠的 SQL 查詢，減少了因不明確的 GROUP BY 操作而導致的潛在錯誤。</p><h2 id="如何解決？"><a href="#如何解決？" class="headerlink" title="如何解決？"></a>如何解決？</h2><p>好了，廢話這麼多，該進入正題了。</p><p>除了把語法通通修好的方法外，我們可能需要的是趕快解決這問題，並且可以繼續向下開發的解決辦法。</p><p>其實就把這設定給<code>關</code>了就行了</p><h2 id="錯誤追蹤"><a href="#錯誤追蹤" class="headerlink" title="錯誤追蹤"></a>錯誤追蹤</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/../Images-Posts/only-full-group-by-problem/error.png"                      alt="error"                ></p><p>出現這個錯誤後繼續往下追查至 mysql，進入 mysql cli 之後輸入下面語法查看</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@sql_mode</span>;</span><br></pre></td></tr></table></figure></div><p>我的環境輸入後會出現下面這樣的畫面：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/../Images-Posts/only-full-group-by-problem/sql_mode_list_in_m.png"                      alt="error"                ></p><p>可以看到確實出現了 <code>ONLY_FULL_GROUP_BY</code> 的設定，也就是這個設定導致很多語法都無法『正常』執行。因此我們需要把它關閉。</p><h2 id="關閉ONLY-FULL-GROUP-BY"><a href="#關閉ONLY-FULL-GROUP-BY" class="headerlink" title="關閉ONLY_FULL_GROUP_BY"></a>關閉<code>ONLY_FULL_GROUP_BY</code></h2><p>如果是 homebrew 安裝的 <a class="link"   href="mailto:&#109;&#121;&#x73;&#113;&#x6c;&#x40;&#53;&#46;&#55;" >&#109;&#121;&#x73;&#113;&#x6c;&#x40;&#53;&#46;&#55;<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 路徑，需編輯<code>/opt/homebrew/etc/my.cnf</code> 這個設定檔。並在裡面加入你需要開啟的 sql_mode。否則用下語法的方式每次重啟 mysql 都會恢復到預設設定。</p><p>準備把下面這段設定貼到 config 中</p><blockquote><p><code>sql_mode = &quot;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION”</code></p></blockquote><p>貼上去後畫面如下（注意要在 <code>mysqld</code>) 的區塊下：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/../Images-Posts/only-full-group-by-problem/sqlmode.png"                      alt="modifycnf"                ></p><p>接著重新啟動你的 mysql</p><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services restart mysql@5.7</span><br></pre></td></tr></table></figure></div><p>完成！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;MySql 版本 5.7 以上都會自己預設開啟這個 &lt;code&gt;ONLY_FULL_GROUP_BY&lt;/code&gt;。這個設定的目的主要是提高</summary>
      
    
    
    
    <category term="RubyOnRails" scheme="https://larrylai1993.github.io/categories/RubyOnRails/"/>
    
    <category term="Database" scheme="https://larrylai1993.github.io/categories/RubyOnRails/Database/"/>
    
    
    <category term="RubyOnRails" scheme="https://larrylai1993.github.io/tags/RubyOnRails/"/>
    
    <category term="ActiveRecord" scheme="https://larrylai1993.github.io/tags/ActiveRecord/"/>
    
    <category term="MySql" scheme="https://larrylai1993.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>N+1 Query Problem</title>
    <link href="https://larrylai1993.github.io/2024/07/17/n-plus-one-problem/"/>
    <id>https://larrylai1993.github.io/2024/07/17/n-plus-one-problem/</id>
    <published>2024-07-17T10:00:00.000Z</published>
    <updated>2026-01-09T13:09:22.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近剛從 NET 6 跳來 Rails，免不了要踩到一些新手必踩的坑。像是這個 N+1 查詢問題就是很常見的坑…</p><p>尤其對我這個用 EF 習慣的人，跳到 ActiveRecord 真的是各種不適應。不過不是不好用的不適應，而是那種方便到很沒有安全感的那種便利ＸＤ</p><h1 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h1><blockquote><p>假設你有一個 Customer 和他們的 Order 資料表。當你查詢 Customer 資料時，如果每個 Customer 都有多個 Order，而你同時查詢這些 Order，就會發生 N+1 的查詢問題。</p></blockquote><p>所以當你執行的一個查詢，實際上會有下面兩個動作：</p><ol><li>先執行一個查詢來取得所有 Customer。</li><li>然後對<code>每個</code>Customer 執行一個查詢來取得該 Customer 的 Order。</li></ol><blockquote><p>如果有 N 個 Customer，你將會執行 1 + N 個查詢，這會導致效能問題。</p></blockquote><p>簡單來說，N+1 查詢問題就是當你需要多次查詢資料庫才能取得完整資料時，會造成大量不必要的查詢，影響效能。</p><h1 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h1><h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><div class="code-container" data-rel="Ruby"><figure class="iseeu highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Customer</span>.includes(<span class="symbol">:orders</span>).all</span><br></pre></td></tr></table></figure></div><p>把需要的資料一次撈出來，轉換成 SQL 語法的話就是使用了 IN (‘1’,’2’,’3’) 這樣的方式來一次性預先載入。避免重複向資料庫存取。</p><h2 id="eager-load"><a href="#eager-load" class="headerlink" title="eager_load"></a>eager_load</h2><div class="code-container" data-rel="Ruby"><figure class="iseeu highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Customer</span>.eager_load(<span class="symbol">:orders</span>).all</span><br></pre></td></tr></table></figure></div><ol><li>eager_load 強制使用 LEFT OUTER JOIN 來載入關聯資料。在一個查詢中同時載入主要資料和關聯資料。</li><li>適合在需要對關聯資料進行條件篩選或排序時使用。</li></ol><h2 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h2><div class="code-container" data-rel="Ruby"><figure class="iseeu highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Customer</span>.preload(<span class="symbol">:orders</span>).all</span><br></pre></td></tr></table></figure></div><p>preload 強制使用多次查詢來載入關聯資料。它會先查詢主要資料，再查詢關聯資料，這樣可以避免 JOIN 查詢的開銷。<br>適合在不需要對關聯資料進行條件篩選時使用。</p><p>上述提到的<code>多次查詢</code> 是會轉換成下面這樣的 SQL 語法：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查詢顧客</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers;</span><br><span class="line"><span class="comment">-- 查詢所有相關顧客的訂單</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> orders.customer_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...);</span><br></pre></td></tr></table></figure></div><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>一般來說都是直接選擇使用<code>includes</code>，因為 includes 會選擇最優的查詢策略。它會根據上下文決定是使用單獨查詢還是 JOIN 查詢。</p><p>當只讀取資料而沒有條件篩選時，通常會進行兩次查詢（preload）。</p><p>當涉及條件篩選並需要 JOIN 查詢時，它會自動使用 LEFT OUTER JOIN（eager_load）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近剛從 NET 6 跳來 Rails，免不了要踩到一些新手必踩的坑。像是這個 N+1 查詢問題就是很常見的坑…&lt;/p&gt;
&lt;p&gt;尤其對我這個</summary>
      
    
    
    
    <category term="RubyOnRails" scheme="https://larrylai1993.github.io/categories/RubyOnRails/"/>
    
    
    <category term="RubyOnRails" scheme="https://larrylai1993.github.io/tags/RubyOnRails/"/>
    
    <category term="ActiveRecord" scheme="https://larrylai1993.github.io/tags/ActiveRecord/"/>
    
  </entry>
  
  <entry>
    <title>如何處理 Kubernetes 無法 Pull 私有鏡像庫的問題?</title>
    <link href="https://larrylai1993.github.io/2024/04/24/k8s-pulling-image-failed/"/>
    <id>https://larrylai1993.github.io/2024/04/24/k8s-pulling-image-failed/</id>
    <published>2024-04-24T10:00:00.000Z</published>
    <updated>2026-01-09T13:09:22.050Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E7%A7%81%E6%9C%89%E9%8F%A1%E5%83%8F%E5%BA%AB%E7%84%A1%E6%B3%95%E6%8B%89%E5%8F%96">私有鏡像庫無法拉取</a><ul><li><a href="#docker">Docker</a></li><li><a href="#k8s-containerd">K8S Containerd</a></li><li><a href="#pod-%E5%A4%B1%E6%95%97-images-%E7%84%A1%E6%B3%95%E6%88%90%E5%8A%9F%E6%8B%89%E5%8F%96">POD 失敗, Images 無法成功拉取</a></li></ul></li></ul><h2 id="私有鏡像庫無法拉取"><a href="#私有鏡像庫無法拉取" class="headerlink" title="私有鏡像庫無法拉取"></a>私有鏡像庫無法拉取</h2><p>Private Image Repository 通常會因為不安全的關係而導致無法正常拉取。所以在拉取之前需要先行設定。這件事情分成兩個面向，也因此有兩個地方要進行設定。</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p><strong>透過 docker pull image 來取得 Image</strong></p><ul><li><p>將不信任的鏡像庫加入到信任清單中</p><p>需要先調整 docker 的設定檔，信任這個私有的 Repository。我們可以先進入 <code>/etc/docker</code>。進入後如果沒有 <code>daemon.json</code> 則需要自行建立。</p><div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IP和PORT自行更換</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;[IP]:[PORT]&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div></li><li><p>調整 docker.service 啟動帶入的參數</p><ul><li><code>sudo vi /usr/lib/systemd/system/docker.service</code></li><li>在 restart&#x3D;always 下方加入 <code>EnvironmentFile=/etc/docker/daemon.json</code></li></ul></li><li><p>重啟 docker.service</p><div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">systemctl restart docker.service</span><br><span class="line">systemctl status docker.service</span><br></pre></td></tr></table></figure></div></li><li><p>執行登入</p><div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker login [IP:Port] -u [UserName]</span><br></pre></td></tr></table></figure></div></li><li><p>Pull Image</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [IP:Port]/[Image Name]:[tag]</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="K8S-Containerd"><a href="#K8S-Containerd" class="headerlink" title="K8S Containerd"></a>K8S Containerd</h3><p>因為剛才已經利用 docker pull 拉取過 Image。在後續的 yaml 檔中，我們都需要有個認證能夠讓 K8S 使用，而非透過在每一個 Worker node 執行 docker login 。</p><p>在這裡我們使用剛才 docker login 所產生的檔案來建立 K8S 的 Secret File。或不利用檔案而是指定好帳號密碼來產生 Secret File。</p><ul><li><p>產生 secret</p><ol><li>利用 docker login 產生的檔案</li></ol><div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret generic regcred \</span><br><span class="line">--from-file=.dockerconfigjson=autoConf.json \</span><br><span class="line">--<span class="built_in">type</span>=kubernetes.io/dockerconfigjson</span><br></pre></td></tr></table></figure></div><ol start="2"><li>自行輸入資訊產生</li></ol><div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret docker-registry insecure-registry \ --docker-server=[IP:Port] --docker-username=[User Name] \ --docker-password=&#x27;[Password]&#x27; --docker-email=[User Email]</span><br></pre></td></tr></table></figure></div><p>可以嘗試使用上面任一種方式產生，或兩種都行。在產生 Secret 後執行下面的語法，在<code>Auth</code>的欄位應該要完全相同。</p><div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get secret [Secret Name] --output=&quot;jsonpath=&#123;.data.\.dockerconfigjson&#125;&quot; | base64 --decode</span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># decode opaque</span><br><span class="line">kubectl get secrets/mongodb-secret --template=&#x27;&#123;&#123; index .data &quot;填入secret內欄位的名稱&quot; | base64decode&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure></div></li><li><p>產生 secret 之後將其套用進 deploy yaml 中。</p><div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dockerdemo-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">uat-example</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">uat-example</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">uat-example-api</span></span><br><span class="line">          <span class="attr">image:</span> <span class="number">10.1</span><span class="number">.23</span><span class="number">.49</span><span class="string">:8082/example-api:dev</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8034</span></span><br><span class="line">      <span class="attr">imagePullSecrets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">regcred</span> <span class="comment">#secret name</span></span><br></pre></td></tr></table></figure></div></li><li><p>k8s deploy</p><pre><code> kubectl apply -f [File Name]</code></pre></li></ul><h3 id="POD-失敗-Images-無法成功拉取"><a href="#POD-失敗-Images-無法成功拉取" class="headerlink" title="POD 失敗, Images 無法成功拉取"></a>POD 失敗, Images 無法成功拉取</h3><p>這時候可能會遭遇到問題，當你執行 <code>kubectl get pods</code> 的時候會發現沒有任何一個 pod 被啟動成功。再次執行 <code>kubectl describe pods [pod name]</code> 則會看見：</p><blockquote><p>錯誤訊息：http: server gave HTTP response to HTTPS client 的相關錯誤</p></blockquote><p>你可能會好奇，我 docker pull image 都能成功了，為什麼由 k8s 執行 pull 反而就失敗了？</p><p>原因是因為 K8S 是透過使用 Container Runtime Interface（CRI）作為介面與容器執行時引擎（container runtime）進行通信。而在我們這個架構，我們的 CRI 是 Containerd，所以要為 Containerd 加入 Registry 的映射。</p><ol><li><p>進入<code>/etc/containerd</code>，開啟 <code>config.toml</code>，如果沒有則自行建立。</p></li><li><p>在裡面填入</p><div class="code-container" data-rel="Toml"><figure class="iseeu highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Config file is parsed as version 1 by default.</span></span><br><span class="line"><span class="comment"># To use the long form of plugin names set &quot;version = 2&quot;</span></span><br><span class="line"><span class="section">[plugins.cri.registry.mirrors]</span></span><br><span class="line">  <span class="section">[plugins.cri.registry.mirrors.&quot;IP:PORT&quot;]</span></span><br><span class="line">    <span class="attr">endpoint</span> = [<span class="string">&quot;http://IP:PORT&quot;</span>]</span><br></pre></td></tr></table></figure></div><p>這個用意是指當遇到指定的 IP 和 PORT 的時候，轉成使用<code>http</code>去呼叫，而非預設的<code>https</code>。</p></li><li><p>重啟 containerd</p><div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart containerd</span><br></pre></td></tr></table></figure></div></li></ol><p>接著刪除原本的 deploy，重新 apply 一次就可以正常拉取 image。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%A7%81%E6%9C%89%E9%8F%A1%E5%83%8F%E5%BA%AB%E7%84%A1%E6%B3%95%E6%8B%89%E5%8F%96&quot;&gt;私有鏡像庫無法拉取&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#docker</summary>
      
    
    
    
    
    <category term="Kubernetes" scheme="https://larrylai1993.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Message Queue 簡單介紹與比較</title>
    <link href="https://larrylai1993.github.io/2023/11/25/message-queue-introduce/"/>
    <id>https://larrylai1993.github.io/2023/11/25/message-queue-introduce/</id>
    <published>2023-11-25T01:19:28.000Z</published>
    <updated>2026-01-09T13:09:22.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h1><blockquote><p>Message Queue 訊息佇列，既然資料結構如其名是 Queue，那麼 FIFO 先進先出的概念就得先了解。存放於 Queue 中的即是 Message。</p></blockquote><p>主要用途在於提供 <code>不同Process</code> 、 <code>不同Thread</code> 或是在微服務中各個 Service 之間的<strong>訊息溝通</strong>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/../Images-Posts/2_MQ_Process.png"                      alt="MQ_Process"                ></p><h2 id="Application-Intergration"><a href="#Application-Intergration" class="headerlink" title="Application Intergration"></a>Application Intergration</h2><blockquote><p>在一個系統中，一般不會只有一隻程式在運作，而是會有多隻程式同時負責各種不同的任務，而程式之間難免會有互相傳遞資料進行處理的需求，而這類的需求，以下都統稱為 applcation 的整合。</p></blockquote><ul><li><p>File Based Intergration</p><p>Application 根據要處理的任務，產生檔案到特定的路徑。其中任務成功或失敗可以存放到不同 folder 中。而其他接收訊息的 application(或稱 process application) 則是不停監控該路徑有沒有新檔案產生，有則取出檔案進行處理。</p></li><li><p>Shared Database Intergration</p><ol><li>source application 收到新任務時，將資料寫入 db 中</li><li>process application 監聽的對象從路徑中的檔案換成 database，若有新資料則進行處理</li><li>process application 處理後將狀態寫回 db 中</li></ol></li><li><p>Direct Connection Intergration</p><ol><li>source application 直接傳訊息給 process application</li><li>可能透過 TCP&#x2F;IP 或是 named pipe connection 的方式傳遞資料</li><li>傳遞資訊的資料格式並沒有限制，由連線兩端的 application 自訂，可以是純文字、XML 或 JSON。</li></ol></li><li><p><strong>Asynchronous Message Broker (Message Queue)</strong></p><ol><li>不限傳遞資料格式</li><li>需要額外 message queue middleware 協助，也會被稱作 message broker 或 message bus</li><li>message broker 收到來自 source application 的訊息後，會轉發給 process application，而在這方式中，source application 與 process application 通常又各自被稱為 producer 與 consumer。</li></ol></li></ul><h2 id="特性-優勢"><a href="#特性-優勢" class="headerlink" title="特性 &amp; 優勢"></a>特性 &amp; 優勢</h2><p>Message Queue 最重要的能力在於<strong>非同步</strong>的特性，因為 Producers 發送訊息時不需即刻得到 Response 便可繼續執行其他事情。</p><p>之於非同步的特性伴隨著的優勢便是解耦(Decouple)，開發人員就可以專心負責在屬於自己的區塊進行工作。除此之外 Producer 無需清楚 Consumer 的實際位置(IP Address 等等)，只需要將資料送往 Message Queue 就好，剩下的事情 Message Broker 會根據設定自行處理掉。</p><p>再來高可用性，例如<strong>叢集的高可用性</strong>，當 Master 處於異常狀態時，會轉由 Slave 進行代理繼續提供服務。以確保服務的運行來提供叢集的高可用性。另外則是<strong>資料的高可用性</strong>，當 Message 送至 Queue 但服務發生異常(如 Consumer 消失時)，資料仍然可等到 Consumer 重新上線時再進行推送(Push)或是被拉取(Pull)，直到 Message 被正確消耗後會發出 Ack (Acknowledgement) 確認通知之後 Message 則會消失。</p><p>最後則是 Scaling 擴展，如果突然遭遇大的流量，此時 queue 就提供了一個 buffer 的功能，能夠緩衝尖峰流量，在資源固定的情況下，能夠處理更多的任務，以時間換取資源！ 但有時訊息可能真的太多，產生的速度快於消耗的速度，或是你無法接受太長的 latency，此時 consumer process 就可以隨時增加多個，不會有衝突的風險</p><p>另外，先進先出的佇列資料結構也直接確保了資料的有序性。</p><h2 id="Use-Case"><a href="#Use-Case" class="headerlink" title="Use Case"></a>Use Case</h2><ul><li><p><strong>延遲問題不重要的工作</strong></p><p>寄送郵件這類工作，使用者可以接受信晚個幾秒，幾十秒甚至幾分鐘到時。意即資料不是由使用者寫入，使用者也不曉得資料何時應該要出現，延遲問題就不是那麼重要。</p></li><li><p><strong>大量運算的工作</strong></p><p>比如說 image resizing 或是 video encoding 這類 CPU intensive 的工作，一來是使用者上傳完圖片影片，可能不需要等到這類都做完了你才跟他說 ok，二來是你也不會想讓這類工作 block 住或拖垮你的 web server 的效能．</p></li><li><p><strong>無法控制的工作</strong></p><p>當你的工作需要協調許多資源才能完成時，有機會因為其中一個資源負載過重因而造成整個工作變得極度緩慢，尤其資源是外部的，所以你無法控制的時候。</p></li></ul><h2 id="Kafka-與-RabbitMQ-的抉擇"><a href="#Kafka-與-RabbitMQ-的抉擇" class="headerlink" title="Kafka 與 RabbitMQ 的抉擇"></a>Kafka 與 RabbitMQ 的抉擇</h2><p>比較兩者之前應該先了解 Message Queue 分成兩種：</p><ol><li>Memory Based</li><li>Log Based</li></ol><ul><li><p><strong>Memory Based (RabbitMQ)</strong></p><ul><li>Message 是<strong>存放於 Memory</strong></li><li>Consumer 發出 Ack(Acknowledgement) 確認 Message 取得後 Broker 則會直接刪除 Message</li><li>Message 傳送方式是<code>推送(Push)</code></li></ul></li><li><p><strong>Log Based (Kafka)</strong></p><ul><li>Message 進入後會直接<strong>寫到硬碟</strong>上，Consumer 消耗訊息時則是讀取檔案，直到讀到檔案資料的盡頭，接著繼續等候下一次通知。</li><li>Message 傳送方式為<code>拉取(Pull)</code></li></ul></li></ul><blockquote><p>Log Based 的讀寫速度限制則可透過將 topic 的 log 進行分區來進行改善，每個分區(Partition)由一台機器負責，並可獨立讀寫。</p></blockquote><p>了解了兩種基底的 MQ 差異後，接著了解他們兩者特性上的差異。</p><p>先以簡易的比較表概括：</p><table><thead><tr><th>特性</th><th>RabbitMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>Load Balancing</td><td>Yes</td><td>Yes, but limited</td></tr><tr><td>Fan-out</td><td>Yes, through exchange binding</td><td>Yes</td></tr><tr><td>Persistence</td><td>Yes, through configuration</td><td>Yes</td></tr><tr><td>Inorder delivery</td><td>Yes, conditionally</td><td>yes, per partition</td></tr></tbody></table><ul><li><p><code>Load Balancing(負載平衡)</code></p><ul><li><p><strong>Memory based</strong></p><p>自然地 support 了 load balancing，當有 message 時， broker 輪流地向跟他有建立連結的 consumer 推送信息，就達成了 load balancing 的效果， 越多 consumer，就可以平行處理越多的工作。</p></li><li><p><strong>Log based</strong></p><p>需透過方才提到的 Partition 方法來達成 load balancing。<br>例如一個 topic，並且將此 topic 的 partition 分成三份，此時就可以 assign 三個 consumer 給他。感覺上像是一個 topic 的 message 被提供給三個 consumer 拉取。但實際上則是每個 partition 對應到一個 consumer，便實現了平行處理，意即達到負載平衡。</p></li></ul></li><li><p><code>Fan-Out(扇形發送)</code></p><ul><li><p><strong>Memory based</strong></p><p>需要透過額外的設計才能達成，透過 AMQP 協議的 exchange binding 可以實現 pub-sub。</p></li><li><p><strong>Log based</strong></p><p>本身即為 fan-out，每個 consumer 對 log 檔案想讀哪就讀哪，想重複讀幾次就讀幾次</p></li></ul></li><li><p><code>Persistence(持續性)</code></p><ul><li><p><strong>Memory based</strong></p><p>可透過設置將 Message 寫入硬碟作為 Backup 時使用，但僅保存到 Consumer 成功消耗之前。</p></li><li><p><strong>Log based</strong></p><p>每個 message 都會寫入硬碟，除非刪掉它，否則會一直存在。</p></li></ul></li><li><p><code>Inorder delivery(有序發送)</code></p><ul><li><p><strong>Memory based</strong></p><p>無法保證 message 一個一個按照順序的被處理，除非每一個 topic 只有一個 consumer。</p></li><li><p><strong>Log based</strong></p><p>每個 partition 上的 message，一定是被 consumer 有序讀取，但不同 partition 之間就沒有順序的保證，他們理論上是各自獨立的。</p></li></ul></li></ul><h2 id="最終選擇誰"><a href="#最終選擇誰" class="headerlink" title="最終選擇誰"></a>最終選擇誰</h2><p>需考慮下列三點</p><ol><li><p>資料是否需要被保存?</p><ul><li>需要保存鐵定是選擇 log based 的 MQ，也就是 Kafka。</li></ul></li><li><p>資料有序性是否重要?</p><ul><li>針對系統開發的面向判斷是否需要維持資料的有序性，如果需要的話則需要選擇 Log Based。但這也僅限於同一個 Partition，若不同的話則無法保證順序。</li></ul></li><li><p>工作耗損是否昂貴?</p><ul><li>log based 受限於需要多個 partition 來實現負載平衡來提升讀寫速度，建設上較為昂貴。</li><li>同個 Partition 只要 Message 過多容易消耗更多時間，最後造成堵塞。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Message-Queue&quot;&gt;&lt;a href=&quot;#Message-Queue&quot; class=&quot;headerlink&quot; title=&quot;Message Queue&quot;&gt;&lt;/a&gt;Message Queue&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Message Queue</summary>
      
    
    
    
    <category term="Basic" scheme="https://larrylai1993.github.io/categories/Basic/"/>
    
    
    <category term="MicroService" scheme="https://larrylai1993.github.io/tags/MicroService/"/>
    
    <category term="MessageQueue" scheme="https://larrylai1993.github.io/tags/MessageQueue/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 介紹與使用KIND簡單建置Cluster/Local Registry</title>
    <link href="https://larrylai1993.github.io/2023/11/24/k8s-introduce-1/"/>
    <id>https://larrylai1993.github.io/2023/11/24/k8s-introduce-1/</id>
    <published>2023-11-24T06:40:56.000Z</published>
    <updated>2026-01-09T13:09:22.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-K8S"><a href="#Kubernetes-K8S" class="headerlink" title="Kubernetes(K8S)"></a>Kubernetes(K8S)</h1><p>Kubernetes 是一個協助我們自動化部署、擴張以及管理容器應用程式(containerized applications)的系統。相較於需要手動部署每個容器化應用程式(containers)到每台機器上，</p><ul><li><a href="#kubernetesk8s">Kubernetes(K8S)</a><ul><li><a href="#k8s-%E6%9E%B6%E6%A7%8B">K8S 架構</a></li><li><a href="#%E4%BB%80%E9%BA%BC%E6%98%AF-k8s">什麼是 K8S</a></li><li><a href="#%E4%BD%BF%E7%94%A8-kind-%E6%9E%B6%E8%A8%AD-k8s-cluster">使用 KinD 架設 K8S Cluster</a></li><li><a href="#k8s-dashboard">K8S Dashboard</a></li><li><a href="#kind-local-registry">KinD Local Registry</a><ul><li><a href="#%E5%BB%BA%E7%AB%8B%E5%A5%BD-local-registry-%E7%84%B6%E5%BE%8C%E5%91%A2">建立好 Local Registry 然後呢?</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4">常用指令</a></li></ul></li></ul><h2 id="K8S-架構"><a href="#K8S-架構" class="headerlink" title="K8S 架構"></a>K8S 架構</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/../Images-Posts/2_k8s-pods.png"                      alt="k8sPod"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="/../Images-Posts/2_components-of-kubernetes.svg"                      alt="k8sPod2"                ></p><h2 id="什麼是-K8S"><a href="#什麼是-K8S" class="headerlink" title="什麼是 K8S"></a>什麼是 K8S</h2><p>Kubernetes 可以幫我們做到以下幾件事情：</p><ol><li>同時部署多個 containers 到一台機器上，甚至多台機器。</li><li>管理各個 container 的狀態。如果提供某個服務的 container 不小心 crash 了，Kubernetes 會偵測到並重啟這個 container，確保持續提供服務</li><li>將一台機器上所有的 containers 轉移到另外一台機器上。</li><li>提供機器高度擴張性。Kubernetes cluster 可以從一台機器，延展到多台機器共同運行。</li></ol><ul><li><p>K8S 架構圖<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/../Images-Posts/2_k8s-arch-all.png"                      alt="KinD_Arch"                ></p></li><li><p><strong>Master Node</strong></p><blockquote><p>在 k8s 中，Master 扮演著管理叢集的角色，管理者可以透過 CLI (Command Line Interface) 或 APIs (Application Programming Interface) 或控制介面 (Dashboard) 等等不同方式與 Master 溝通進而存取、控制或修改叢集狀態例如配置資源、擴充 Pod 數量等等。</p></blockquote><ul><li>Scheduler<ul><li>Scheduler 會知道目前 Worker Node 的狀況，當需要配置 Pod 時，Scheduler 會找出最合適的 Node 並配置 Pod。</li></ul></li><li>API Server<ul><li>管理者會透過 REST command 把需要做的工作 (例如，新增或刪除物件) 傳送到 api-server ， api-server 會驗證並處理管理者要求執行的工作，當工作執行完畢後，叢集的最新狀態便會儲存到 etcd 中。</li></ul></li><li>Controller<ul><li>Controller 會透過 api-server 了解目前叢集的狀態，並嘗試把目前狀態調整為管理者想要的狀態。</li><li>管理者想要的狀態可能會因為種種原因無法達成，例如資源不夠 (cpu, memory) 等等。而 Controller 會持續嘗試著把叢集調整成管理者想要的狀態。</li></ul></li><li>etcd<ul><li>etcd 為鍵值儲存區 (key-value storage)，在 k8s 中被用來儲存叢集的狀態。</li><li>etcd 可以是 Master 的一部分或者獨立被設置在外部。同樣的，當 etcd 被設置在外部時，Master 會連到 etcd 取得或更新叢集狀態。</li></ul></li></ul></li><li><p><strong>Worker Node</strong></p><blockquote><p>Worker Node 簡單來說就是一台機器，它可以是一台實體機器或虛擬機 (VMs)。而多個運行單位 Pod 會被配置到 Worker Node 中運行，而每個 Pod 中含有一到多個容器。</p></blockquote><ul><li>kubelet<ul><li>kubelet 運行在 Worker Node，負責建立 Pod 中的容器。當 kubelet 收到來自 Master Node 送來 Pod 定義內容時，kubelet 會透過 container runtime 建立 Pod 需要的容器並確保容器狀態是可運行的。</li></ul></li><li>kube-proxy<ul><li>當 Pod 運行在 Worker Node 之後，外部需要透過 Service 這個 k8s 物件來與 Pod 連線而非直接存取 Pod。<br>kube-proxy 運行在 Worker Node 且持續監聽 api-server，並知道 Service 被建立或刪除。當 Service 被建立後，kube-proxy 會負責將 Request 導到對應的 Pod。</li></ul></li><li>pod<ul><li>k8s 基本運行單位。</li></ul></li></ul></li></ul><h2 id="使用-KinD-架設-K8S-Cluster"><a href="#使用-KinD-架設-K8S-Cluster" class="headerlink" title="使用 KinD 架設 K8S Cluster"></a>使用 KinD 架設 K8S Cluster</h2><blockquote><p>kind is a tool for running local Kubernetes clusters using Docker container “nodes”.kind was primarily designed for testing Kubernetes itself, but may be used for local development or CI.</p></blockquote><ul><li>Kind 架構圖<br><img                       lazyload                     src="/images/loading.svg"                     data-src="/../Images-Posts/2-Kind-Arch.png"                      alt="KinD_Arch"                ></li></ul><ol><li><p>安裝 KinD</p><ol><li>wsl -l -v</li><li>wsl –set-version Ubuntu-22.04 2</li><li>docker 設定中調整 intergration 與 Ubuntu 整合 WSL2 的環境，讓 Ubuntu 可以直接調用 docker cli</li><li>下載 KinD 並安裝於 Ubuntu<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.17.0/kind-linux-amd64</span><br><span class="line">chmod +x ./kind</span><br><span class="line">sudo mv ./kind /usr/local/bin/kind</span><br></pre></td></tr></table></figure></div></li></ol></li><li><p>建立 K8S Cluster (要先開 Docker Engine Desktop)</p><ol><li>先建立 kind.yaml 檔<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Cluster</span></span><br><span class="line">  <span class="attr">apiVersion:</span> <span class="string">kind.x-k8s.io/v1alpha4</span></span><br><span class="line">  <span class="attr">nodes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">control-plane</span></span><br><span class="line">    <span class="attr">extraPortMappings:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">30000</span> <span class="comment">#容器的port</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="number">5432</span> <span class="comment">#對外開啟的port</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">worker</span></span><br></pre></td></tr></table></figure></div></li><li>使用 yaml 檔建立叢集 <code>kind create cluster --config kind.yaml -n kind</code></li></ol></li><li><p>將做好的 image 複製進去 kind 所建立的 cluster</p><ol><li><p>進入路徑 <strong>..&#x2F;src&#x2F;dockerDemo</strong>，執行<code>docker build -t dockerDemo:latest .</code></p><p>執行好後可以先試試看 <code>docker run -it dockerDemo -p 3000:3000</code>，然後開啟瀏覽器進入 <strong>localhost:3000</strong> 看是否有看見 <strong>Hello World!</strong> 的訊息。</p></li><li><p>在 <strong>Ubuntu</strong> 執行 <code>kind load docker-image -n dockerDemo:latest</code></p></li><li><p>執行 <code>docker exec -it kind-worker crictl image</code> 查看是否有正確讀入 image。</p></li></ol></li><li><p>建立一個 pod，這個 pod 將會直接在 worker 裡面做為一個單位運行，裡面則會包含使用方才的 image 所起的 Container。而建立好該 Pod 之後則需要建立 Service 來貫通整條路。</p><ol><li>建立 <code>00-pods-dockerdemo.yaml</code><div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment">#Pod 使用的 Kubernetes API 是 v1 版本號</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span> <span class="comment">#建立類型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pod</span> <span class="comment">#該 Pod 的名稱</span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#標籤, 後續建立 Service 會使用, 所以要記得</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">webserver</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment">#該 Pod 的描述</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment">#所包含的容器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pod-demo</span> <span class="comment">#容器名稱</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">dockerdemo:latest</span> <span class="comment">#容器映像檔</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">Never</span> <span class="comment">#因為KinD本身已有複製本地的image，所以要設這個。</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3000</span> <span class="comment">#該容器對外開放的 Port</span></span><br></pre></td></tr></table></figure></div></li><li>建立 <code>00-svc-dockerdemo.yaml</code><div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dockerdemo-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3000</span> <span class="comment">#指定建立此Service的Cluster IP中是哪個port number要對應到targetPort</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30000</span> <span class="comment">#指定這個node透過哪個port連接targetPort</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">3000</span> <span class="comment">#指定的Pod的Port號, 也就是外部會透過port 30000對應到此pod的port 3000</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">webserver</span> <span class="comment">#將特定的port號收到的請求導向app:webserver標籤的pods</span></span><br></pre></td></tr></table></figure></div></li><li>建立 Pods，執行 <code>kubectl apply -f 00-pods-dockerdemo.yaml</code></li><li>有了 Pod 之後，需打通其橋梁，因此建立 Service。 執行 <code>kubectl apply -f 00-svc-dockerdemo.yaml</code></li><li>可確認其有無完整建立，執行 <code>kubectl get [Resource]</code> 來查看。Resource 可改為 svc 或 pods</li></ol></li><li><p>在 Host 主機打開瀏覽器，進入 <code>127.0.0.1:5432</code> 就可以看到 <strong>Hello World!</strong> 字樣。而這個 5432 Port 則是 Host 透過該 Port 進入到 Cluster，並由 Cluster 設定的 5432 進入到 30000，然後觸及到 service 的 3000 去對應到 Pod 的 3000。</p></li></ol><blockquote><p>其實在 Pod 建立好之後，就可以直接透過 Port Foward 的方式來將 Pod 整個暴露給外網的 Port。Port Forward 可以透過 Kubectl 建立起 Proxy 來將外部的流量導入你想進入的 Pod 的 Port。因為要建立起整個 Port 串通是一件不太方便的事情，除此之外在某些狀況也可能暴露整個服務。因此透過這樣的方式能夠更簡便的去除錯。只需要輸入：<code>kubectl port-forward my-pod 8000:3000</code> 。就能透過 Host 的瀏覽器進入 <code>127.0.0.1:8000</code> 就可以看到 **Hello World!**！</p></blockquote><h2 id="K8S-Dashboard"><a href="#K8S-Dashboard" class="headerlink" title="K8S Dashboard"></a>K8S Dashboard</h2><p>因為 KinD 並沒有直接內建儀表板，所以我們得自己安裝回來。</p><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認是否有Pod被建立</span></span><br><span class="line">kubectl get pod -n kubernetes-dashboard -A -w</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>安裝好後需建立使用者來取得權限和建立 Token</p><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding default-admin --clusterrole cluster-admin --serviceaccount=default:default</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get Token</span></span><br><span class="line">kubectl create token default</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run Dashboard</span></span><br><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure></div><p>網址列輸入 <code>http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/login</code> 進入 dashboard，貼入方才的 Token 就可以登入。</p><h2 id="KinD-Local-Registry"><a href="#KinD-Local-Registry" class="headerlink" title="KinD Local Registry"></a>KinD Local Registry</h2><p><strong>如果已實作一個 Cluster 的話，那麼要使用 Local Registry 需要重建一個新的 Cluster。因為 KinD 沒辦法針對叢集的設定去做調整，因此在建立時就必須決定好。</strong></p><blockquote><p>通常在 CI&#x2F;CD 架構中會有個地方存放產出物(Artifact)，無論是 Nuget、Npm 或是 Image，因此我們想透過 KinD 去模擬未來的 CI&#x2F;CD 架構的話，就必須建立一個可以存放產出物的地方。但在初次練習沒有那麼多經驗可能會苦惱究竟要選擇什麼樣的工具或怎麼架。</p></blockquote><p>Nexus Oss Registry、Proget 等等的都可以是未來的解決方案，或者是單純要架設私有的 Image Registry 也可以選擇 Habor。但在這裡我們會選擇最容易架設的 KinD Local Registry。</p><p>KinD Local Registry 架設方式只有兩步，到<a class="link"   href="https://kind.sigs.k8s.io/docs/user/local-registry/" >官網<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>複製執行語法，修改成自己要的。然後在 WSL2 裡面執行就能完成。</p><p>以下是我建立時所使用的執行語法。</p><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"></span><br><span class="line"><span class="comment"># create registry container unless it already exists</span></span><br><span class="line">reg_name=<span class="string">&#x27;kind-registry&#x27;</span></span><br><span class="line">reg_port=<span class="string">&#x27;5001&#x27;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(docker inspect -f &#x27;&#123;&#123;.State.Running&#125;&#125;&#x27; <span class="string">&quot;<span class="variable">$&#123;reg_name&#125;</span>&quot;</span> 2&gt;/dev/null || true)</span>&quot;</span> != <span class="string">&#x27;true&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">  docker run \</span><br><span class="line">    -d --restart=always -p <span class="string">&quot;127.0.0.1:<span class="variable">$&#123;reg_port&#125;</span>:5000&quot;</span> --name <span class="string">&quot;<span class="variable">$&#123;reg_name&#125;</span>&quot;</span> \</span><br><span class="line">    registry:2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create a cluster with the local registry enabled in containerd</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | kind create cluster --config=-</span></span><br><span class="line"><span class="string">kind: Cluster</span></span><br><span class="line"><span class="string">apiVersion: kind.x-k8s.io/v1alpha4</span></span><br><span class="line"><span class="string">nodes:</span></span><br><span class="line"><span class="string">- role: control-plane</span></span><br><span class="line"><span class="string">  extraPortMappings:</span></span><br><span class="line"><span class="string">    - containerPort: 30000</span></span><br><span class="line"><span class="string">- role: worker</span></span><br><span class="line"><span class="string">containerdConfigPatches:</span></span><br><span class="line"><span class="string">- |-</span></span><br><span class="line"><span class="string">  [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;localhost:$&#123;reg_port&#125;&quot;]</span></span><br><span class="line"><span class="string">    endpoint = [&quot;http://$&#123;reg_name&#125;:5000&quot;]</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># connect the registry to the cluster network if not already connected</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(docker inspect -f=&#x27;&#123;&#123;json .NetworkSettings.Networks.kind&#125;&#125;&#x27; <span class="string">&quot;<span class="variable">$&#123;reg_name&#125;</span>&quot;</span>)</span>&quot;</span> = <span class="string">&#x27;null&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">  docker network connect <span class="string">&quot;kind&quot;</span> <span class="string">&quot;<span class="variable">$&#123;reg_name&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Document the local registry</span></span><br><span class="line"><span class="comment"># https://github.com/kubernetes/enhancements/tree/master/keps/sig-cluster-lifecycle/generic/1755-communicating-a-local-registry</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | kubectl apply -f -</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: ConfigMap</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: local-registry-hosting</span></span><br><span class="line"><span class="string">  namespace: kube-public</span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">  localRegistryHosting.v1: |</span></span><br><span class="line"><span class="string">    host: &quot;localhost:$&#123;reg_port&#125;&quot;</span></span><br><span class="line"><span class="string">    help: &quot;https://kind.sigs.k8s.io/docs/user/local-registry/&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="建立好-Local-Registry-然後呢"><a href="#建立好-Local-Registry-然後呢" class="headerlink" title="建立好 Local Registry 然後呢?"></a>建立好 Local Registry 然後呢?</h3><ol><li>建立 Docker Image</li><li>將 Image Push 上去 Registry</li><li>透過建立 Deployment 來部署</li><li>透過建立 Service 讓主機能通到 Node 裡 Pod 的 Container</li></ol><p><strong>建立 Docker Image</strong></p><pre><code>進入路徑 ../src/dockerDemo，執行`docker build -t dockerDemo:latest .`</code></pre><p><strong>Tag Image Local Registry</strong></p><pre><code>docker tag dockerDemo localhost:5001/dockerDemo:latest</code></pre><p><strong>Push Image To Local Registry</strong></p><pre><code>docker push localhost:5001/dockerDemo</code></pre><p>執行後可以看見像這樣的訊息：</p><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Using default tag: latest</span><br><span class="line">The push refers to repository [localhost:5001/dockerDemo]</span><br><span class="line">9992941a9f7b: Pushed</span><br><span class="line">e9f76b9eead8: Pushed</span><br><span class="line">e40a27ff8335: Pushed</span><br><span class="line">ea0f922ba68b: Pushed</span><br><span class="line">1f6b17cd478d: Pushed</span><br><span class="line">17bec77d7fdc: Pushed</span><br><span class="line">latest: digest: sha256:05e38376828b2d2279517c04e93c2a0b072abbaf0fcbc8e32422c047e9a2c03d size: 1578</span><br></pre></td></tr></table></figure></div><p><strong>建立 Deployment 部署，在這裡會向 Local Registry Pull Image</strong></p><pre><code>kubectl create deployment test-dockerDemo --image=localhost:5001/dockerDemo</code></pre><p><strong>可以檢查 Pod 是否正常運作中</strong></p><pre><code>kubectl get pods -o wide</code></pre><p><strong>建立 Service 打通 Host 和 Node</strong></p><div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dockerdemo-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30000</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">3000</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">test-dockerdemo</span></span><br></pre></td></tr></table></figure></div><p>透過 <code>docker ps</code> 可以看見 K8S 的 Container 的 30000 port 是對應到 Host 的哪個 Port 對外開放。得知之後只要在 Host 的 Browser 進入 127.0.0.1:[<strong>Port</strong>] 就能看見 Hello World!。</p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get image list in kind (cluster1 叢集名稱)</span></span><br><span class="line">docker <span class="built_in">exec</span> -it cluster1-worker crictl image</span><br><span class="line"></span><br><span class="line"><span class="comment"># load image to k8s cluster</span></span><br><span class="line">kind load docker-image redis:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># get login token</span></span><br><span class="line">kubectl create token default</span><br><span class="line"></span><br><span class="line"><span class="comment"># get cluster info</span></span><br><span class="line">kubectl cluster-info</span><br><span class="line"></span><br><span class="line"><span class="comment"># get cluster config</span></span><br><span class="line">kubectl config view</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kubernetes-K8S&quot;&gt;&lt;a href=&quot;#Kubernetes-K8S&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes(K8S)&quot;&gt;&lt;/a&gt;Kubernetes(K8S)&lt;/h1&gt;&lt;p&gt;Kubernetes 是一個協助我們自動</summary>
      
    
    
    
    
    <category term="Kubernetes" scheme="https://larrylai1993.github.io/tags/Kubernetes/"/>
    
  </entry>
  
</feed>
